# Transcript from: Intro to Algorithms_ Crash Course Computer Science #13.mp4
# Generated on: 2025-09-14T15:04:58.829Z
# ============================================

[00:00] Hi, I'm Carrie Ann, and welcome to Crash Course Computer Science. Over the past two episodes, we got our first taste of programming in a high-level language like Python or Java. We talked about different types of programming language statements, like assignments, ifs, and loops, as well as putting statements into functions that perform a computation like calculating an exponent. Importantly, the function we wrote to calculate exponents is only one possible solution. There are other ways to write this function using different statements in different orders that achieve exactly the same numerical result. The difference between them is the algorithm, that is the specific steps used to compute the computation. Some algorithms are better than others, even if they produce equal results. Generally, the fewer steps it takes to compute, the better it is, though sometimes we care about other factors like how much memory it uses. The term algorithm comes from Persian polymath Muhammad ibn Musa al-Khwarizmi, who was one of the fathers of algebra more than a millennium ago. The crafting of efficient algorithms, a problem that existed long before modern computers, led to a whole science surrounding computation, which evolved into the modern discipline of, you guessed it, computer science.

[01:16] One of the most storied algorithmic problems in all of computer science is sorting, as in sorting names or sorting numbers. Computers sort all the time; looking for the cheapest airfare, arranging your email by most recently sent, or scrolling your contacts by last name. Those all require sorting. You might think sorting isn't so tough. How many algorithms can there possibly be? The answer is a lot. Computer scientists have spent decades inventing algorithms for sorting with cool names like bubble sort and spaghetti sort. Let's try sorting. Imagine we have a set of airfare prices to Indianapolis. We'll talk about how data like this is represented in memory next week, but for now, a series of items like this is called an array. Let's take a look at these numbers to help see how we might sort this programmatically. We'll start with a simple algorithm. First, let's scan down the array to find the smallest number. Starting at the top with 307, it's the only number we've seen, so it's also the smallest. The next is 239. That's smaller than 307, so it becomes our new smallest number. Next is 214, our new smallest number. 250 is not, neither is 384, 299, 223, or 312. So, we've finished scanning all numbers, and 214 is the smallest. To put this into ascending order, we swap 214 with the number in the top location. Great, we sorted one number. Now we repeat the same procedure, but instead of starting at the top, we can start one spot below. First, we see 239, which we save as our new smallest number. Scanning the rest of the array, we find 223 is the next smallest. So, we swap this with the number in the second spot. Now we repeat again, starting from the third number down. This time, we swap 239 with 307. This process continues until we get to the very last number. And voil√†, the array is sorted, and you're ready to book that flight to Indianapolis. The process we just walked through is one way or one algorithm for sorting an array. It's called selection sort, and it's pretty basic. Here's the pseudo code. This function can be used to sort eight, eighty, or eighty million numbers, and once you've written the function, you can use it over and over again. With this sort algorithm, we loop through each position in the array from top to bottom, and then for each of those positions, we have to loop through the array to find the smallest number to swap. You can see this in the code where one for loop is nested inside another for loop. This means very roughly that if we want to sort n items, we have to loop n times, inside of which we loop n times for a grand total of roughly n times n loops or n squared. This relationship of input size to the number of steps the algorithm takes to run characterizes the complexity of the selection sort algorithm. It gives you an approximation of how fast or slow an algorithm is going to be. Computer scientists write this order of growth in something known as, no joke, Big O notation. N squared is not particularly efficient. Our example array had n equals eight items, and eight squared is 64. If we increase the size of our array from eight items to eighty, the running time is now eighty squared, which is 6,400. So, although our array only grew by ten times from eight to eighty, the running time increased by a hundred times from 64 to 6,400. This effect magnifies as the array gets larger. That's a big problem for a company like Google which has to sort arrays with millions or billions of entries. So, you might ask as a burgeoning computer scientist, is there a more efficient sorting algorithm? Let's go back to our old unsorted array and try a different algorithm: merge sort. The first thing merge sort does is check if the size of the array is greater than one. If it is, it splits the array into two halves. Since our array is size eight, it gets split into two arrays of size four. These are still bigger than size one, so they get split again into arrays of size two, and finally, they split into eight arrays with one item in each. Now we are ready to merge, which is how merge sort gets its name. Starting with the first two arrays, we read the first and only value in them. In this case, 307 and 239. 239 is smaller, so we take that value first. The only number left is 307, so we put that value second. We've successfully merged two arrays. We now repeat this process for the remaining pairs, putting them each in sorted order. Then the merge process repeats. Again, we take the first two arrays, and we compare the first numbers in them. This time, it's 239 and 214. 214 is lowest, so we take that number first. Now we look again at the first two numbers in both arrays: 239 and 250. 239 is lower, so we take that number next. Now we look at the next two numbers: 307 and 250. 250 is lower, so we take that. Finally, we're left with just 307, so that gets added last. In every case, we start with two arrays, each individually sorted, and merge them into a larger sorted array. We repeat the exact same merging process for the two remaining arrays of size two. Now we have two sorted arrays of size four. Just as before, we merge, comparing the first two numbers in each array and taking the lowest. We repeat this until all the numbers are merged, and then our array is fully sorted again. The bad news is, no matter how many times we sort these, you're still going to have to pay $214 to get to Indianapolis. Anyway, the Big O computational complexity of merge sort is n times the log of n. The n comes from the number of times we need to compare and merge items, which is directly proportional to the number of items in the array. The log n comes from the number of merge steps. In our example, we broke our array of eight items into four, then two, and finally one. That's three splits. Splitting in half repeatedly like this has a logarithmic relationship with the number of items. Trust me. Log base two of eight equals three splits. If we double the size of our array to 16, that's twice as many items to sort. It only increases the number of split steps by one, since log base two of 16 equals four. Even if we increase the size of our array more than a thousand times, from eight items to 8,000 items, the number of split steps stays pretty low. Log base two of 8,000 is roughly 13. That's more, but not much more than three, about four times larger, and yet we're sorting a lot more numbers. For this reason, merge sort is much more efficient than selection sort, and now I can put my ceramic cat collection in name order much faster. There are literally dozens of sorting algorithms we could review, but instead, I want to move on to my other favorite category of classic algorithmic problems: graph search. A graph is a network of nodes connected by lines. You can think of it like a map with cities and roads connecting them. Routes between these cities take different amounts of time. We can label each line with what is called a cost or weight. In this case, it's weeks of travel. Now let's say we want to find the fastest route for an army at Highgarden to reach the castle of Winterfell. The simplest approach would just be to try every single path exhaustively and calculate the total cost of each. That's a brute force approach. We could have used a brute force approach in sorting by systematically trying every permutation of the array to check if it's sorted. This would have an n factorial complexity, that is the number of nodes times one less, times one less than that, and so on until one, which is way worse than even n squared. But we can be way more clever. The classic algorithmic solution to this graph problem was invented by one of the greatest minds in computer science practice and theory, Edsger Dijkstra, so it's appropriately named Dijkstra's algorithm. We start in Highgarden with a cost of zero, which we mark inside the node. For now, we'll mark all other cities with question marks, as we don't know the cost of getting to them yet. Dijkstra's algorithm always starts with the node with the lowest cost. In this case, it only knows about one node, Highgarden, so it starts there. It follows all paths from that node to all connecting nodes that are one step away and records the cost to get to each of them. That completes one round of the algorithm. We haven't encountered Winterfell yet, so we loop and run Dijkstra's algorithm again. With Highgarden already checked, the next lowest cost node is King's Landing. Just as before, we follow every unvisited line to any connecting cities. The line to the Trident has a cost of five. However, we want to keep a running cost from Highgarden, so the total cost of getting to the Trident is eight plus five, which is 13 weeks. Now we follow the off-road path to Riverrun, which has a high cost of 25 for a total of 33. But we can see inside Riverrun that we've already found a path with a lower cost of just ten, so we disregard our new path and stick with the previous better path. We've now explored every line from King's Landing and didn't find Winterfell, so we move on. The next lowest cost node is Riverrun at ten weeks. First, we check the path to the Trident, which has a total cost of ten plus two or 12. That's slightly better than the previous path we found which had a cost of 13, so we update the path and cost to the Trident. There is also a line from Riverrun to Pyke with a cost of three. Ten plus three is 13, which beats the previous cost of 14, and so we update Pyke's path and cost as well. That's all paths from Riverrun checked, so you guessed it, Dijkstra's algorithm loops again. The node with the next lowest cost is the Trident, and the only line from the Trident that we haven't checked is a path to Winterfell. It has a cost of ten, plus we need to add in the cost of 12 it takes to get to the Trident for a grand total cost of 22. We check our last path from Pyke to Winterfell, which sums to 31. Now we know the lowest total cost and also the fastest route for the army to get there, which avoids King's Landing. Dijkstra's original algorithm, conceived in 1956, had a complexity of the number of nodes in the graph squared. And squared, as we've already discussed, is never great because it means the algorithm can't scale to big problems, like the entire road map of the United States. Fortunately, Dijkstra's algorithm was improved a few years later to take the number of nodes in the graph times the log of the number of nodes plus the number of lines. Although this looks more complicated, it's actually quite a bit faster. Plugging in our example graph with six cities and nine lines proves it. Our algorithm drops from 36 loops to around 14. As with sorting, there are innumerable graph search algorithms with different pros and cons. Every time you use a service like Google Maps to find directions, an algorithm much like Dijkstra's is running on servers to figure out the best route for you. Algorithms are everywhere. The modern world would not be possible without them. We touched only the very tip of the algorithmic iceberg in this episode, but a central part of being a computer scientist is leveraging existing algorithms and writing new ones when needed. And I hope this little taste has intrigued you to search further. I'll see you next week.

[06:54] Crash Course Computer Science is produced in association with PBS Digital Studios. At their channel, you can check out a playlist of shows like PBS Idea Channel, Physics Girl, and It's Okay To Be Smart. This episode was filmed at the Chad and Stacy Emmert Studio in Indianapolis, Indiana, and it was made with the help of all these nice people and our wonderful graphics team, Thought Cafe. Thanks for watching. I'll CPU later.
